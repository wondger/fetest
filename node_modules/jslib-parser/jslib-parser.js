var jsp = require("uglify-js").parser,
	pro = require("uglify-js").uglify,
    util = require("util"),
    pgc = pro.gen_code,
    funcTable = [];

function setFuncMap(name, key, type, startLine, endLine, definition) {
	var obj = {
		"name": name,
		"type": type,
		"key": key,
		"ln": {
			"start": startLine,
			"end": endLine
		},
		"definition": definition
	};
	return obj;
}

function dotGen(parray) {
	var last = "",
	    first = "";

	if (parray.length === 3) {
		last = parray[2];

		if (parray[1].length > 2 ) {
			first = dotGen(parray[1]);
		} else {
			first = parray[1][1];
		}
	}
	return first + "." + last;
}

function searchFunc(givenName) {
	var length = funcTable.length,
		i = 0,
		_item;

	for (;i<length;i++) {
		_item = funcTable[i];
		if (_item.name === givenName) {
			return {
				"name": _item.name,
				"type": _item.type,
				"key": _item.key,
				"ln": {
					"start": _item.ln.start,
					"end": _item.ln.end
				},
				"definition": _item.definition
			};
		}
	}
	return;
}

function libParse(data) {
	var ast = jsp.parse(data, false, true); // parse code and get the initial AST

	var w = pro.ast_walker();
	var ast_add_scope = pro.ast_add_scope;

	var analyzing = [];
    
    function do_stat() {
    	var ret, node, name;
        if (this[0].start && analyzing.indexOf(this) < 0) {
            // without the `analyzing' hack, w.walk(this) would re-enter here leading
            // to infinite recursion
            node = ast_add_scope(this);
            name = this[0].name;
            /*
            if (node.scope) {
            	console.log("this with scope");
            } else {
            	node = ast_add_scope(node);
            }

            console.log("==========");
            console.log(node.scope);
			*/
			/*
			console.log("===================", "start" ,"==>");
			console.log(node.scope);
			console.log("######## code");
			console.log(pro.gen_code(this, {beautify: true}));
			console.log("===================", "end");
			debugger;
			*/
			if (name === "defun") {
				var startLine = this[0].start.line + 1;
				var endLine = this[0].end.line + 1;
				var name = this[1] || "anonymous";
				var type = "method";
				var code = pgc(this, {beautify: true});
				var key = pgc(this);
				funcTable.push(setFuncMap(name, key, type, startLine, endLine, code ));
			} else if (name === "function") {
				var anaLen = analyzing.length,
					i = anaLen,
					match = false;

				var startLine = this[0].start.line + 1;
				var endLine = this[0].end.line + 1;
				var name = "anonymous";
				var type = "method";
				var code = pgc(this, {beautify: true});
				var key = pgc(this);
				var namespace = [];

				for (; i--;) {
					var parent = analyzing[i];
					try {
						if (parent[0].name === "var" || parent[0].name === "object") {
							var pparent = parent[1],
								ppLen = pparent.length,
								pi = 0;

							for (; pi < ppLen; pi++) {
								var pname = pparent[pi][0];
								// debugger;
								var pcode = pgc(pparent[pi][1]);	

								if (pparent[pi] && pparent[pi].length > 1 && pparent[pi][1][0].name === "object") {
									var ppparent = pparent[pi][1][1],
										pppLen = ppparent.length,
										ppi = 0,
										ppname;

									for (; ppi < pppLen; ppi++) {
										ppname = ppparent[ppi][0];

										//debugger;
										if (ppname === namespace[namespace.length - 1]) {
											namespace.push(pname);
											var _ppname = namespace.reverse().join(".");
											namespace.reverse();
											funcTable.push(
												setFuncMap(_ppname, key, type, startLine, endLine, code )
											);
										}
									}

								}

								if (pcode === key) {
									//debugger;
									funcTable.push(
										setFuncMap(pname, key, type, startLine, endLine, code )
									);
									namespace.push(pname);
									match = true;
								}
							}
						} 
					} catch(ex) {
						debugger;
						console.log(ex);
					}

				}

				if(!match) {
					funcTable.push(
						setFuncMap(name, key, type, startLine, endLine, code )
					);
				}
			} else if (name === "assign" ) {
				//debugger;
				try {
					if (this.length === 4) {
						var left = this[2],
							right = this[3];

						if (left[0].name === "name") {
							//debugger;
							var leftName = left[1],
								rightName,
								item;

							if (right[0].name === "name") {
								rightName = right[1];
								if (typeof rightName === "string") {
									item = searchFunc(rightName);

									if (item) {
										funcTable.push(
											setFuncMap(leftName, item.key, item.type, item.ln.start, item.ln.end, item.definition )
										);
									}	
								}
							}else if (right[0].name === "dot") {
								rightName = dotGen(right);
								if (typeof rightName !== ".") {
									item = searchFunc(rightName);

									if (item) {
										funcTable.push(
											setFuncMap(leftName, item.key, item.type, item.ln.start, item.ln.end, item.definition )
										);
									}	
								}

							}
						}	
					}
				} catch (ex) {
					debugger;
					console.log(ex);
				}
			} else if (name === "var") {
				var vars = this[1],
					varsLen = this[1].length,
					i = 0;

				//debugger;
				
				for (; i < varsLen; i++) {
					var p = vars[i],
					    item;
					try{
						if (p.length && p.length === 2) {
							var pname = p[0],
								pnode = p[1];

							if (pnode[0].name === "name") {
								var ppname = pnode[1];
								if (typeof ppname === "string") {
									item = searchFunc(ppname);

									if (item) {
										funcTable.push(
											setFuncMap(pname, item.key, item.type, item.ln.start, item.ln.end, item.definition )
										);
									}	
								}
							} else if (pnode[0].name === "dot") {
								//debugger;
								name = dotGen(pnode);
								if (name !== ".") {
									item = searchFunc(name);
									//debugger;

									if (item) {
										funcTable.push(
											setFuncMap(pname, item.key, item.type, item.ln.start, item.ln.end, item.definition )
										);
									}	
								}
							}
						}
					} catch (ex) {
						debugger;
						console.log(ex);
					}
				}
			} else if (name === "object") {
				//debugger;
				var keys = this[1],
					keysLen = keys.length,
					i = 0,
					namespace = [];

				
				for (; i<keysLen; i++) {
					var key = keys[i],
						keyName = key[0],
						keyValue = key[1];
					try{
						//debugger;
						if (keyValue[0].name === "name") {
							var refName = keyValue[1];
							if (typeof refName === "string") {
								item = searchFunc(refName);

								if (item) {
									funcTable.push(
										setFuncMap(keyName, item.key, item.type, item.ln.start, item.ln.end, item.definition )
									);
									namespace.push(keyName);
									var anaLength;
									if ( (anaLength = analyzing.length) > 0 ) {
										for (; anaLength-- ;) {
											if (analyzing[anaLength][1]) {
												var near = analyzing[anaLength][1][0],
												nearName,
												nearChildren;
											
												if (near && near.length > 1) {
													nearName = near[0];
													nearChildren = near[1];
													if (nearChildren[0].name === "object") {
														var children = nearChildren[1],
															clen = children.length,
															cindex = 0;

														for (;cindex<clen;cindex++) {
															var cname = children[cindex][0];

															if (cname === namespace[namespace.length - 1]) {
																namespace.push(nearName);
																var _cname = namespace.reverse().join(".");
																namespace.reverse();
																funcTable.push(
																	setFuncMap(_cname, item.key, item.type, item.ln.start, item.ln.end, item.definition )
																);
															}
														}

													}
												}
												
											}
										}
									}
								}	
							}
						}
					} catch(ex) {
						debugger;
						console.log(ex);
					}
				}
			}

            analyzing.push(this);
            /*
            ret = [ "splice", // XXX: "block" is safer
                    [ [ "stat",
                        [ "call", [ "name", "trace" ],
                          [ [ "string", this[0].toString() ],
                            [ "num", this[0].start.line ],
                            [ "num", this[0].start.col ],
                            [ "num", this[0].end.line ],
                            [ "num", this[0].end.col ]]]],
                      w.walk(this) ]];
            */
            ret = w.walk(this);
            analyzing.pop(this);
        }
        return ret;
    }

    var new_ast = w.with_walkers({
            "defun": do_stat,
            "assign": do_stat,
            "object": do_stat,
            "var": do_stat,
            "name": do_stat,
            "function": do_stat
    }, function(){
            return w.walk(ast_add_scope(ast));
    });

	return funcTable;
}

exports.libParse = libParse;